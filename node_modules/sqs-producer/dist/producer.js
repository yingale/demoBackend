"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Producer = void 0;
const aws_sdk_1 = require("aws-sdk");
const types_1 = require("./types");
const requiredOptions = [
    'queueUrl'
];
class Producer {
    constructor(options) {
        this.validate(options);
        this.queueUrl = options.queueUrl;
        this.batchSize = options.batchSize || 10;
        this.sqs = options.sqs || new aws_sdk_1.SQS(Object.assign(Object.assign({}, options), { region: options.region || 'eu-west-1' }));
    }
    async queueSize() {
        const result = await this.sqs.getQueueAttributes({
            QueueUrl: this.queueUrl,
            AttributeNames: ['ApproximateNumberOfMessages']
        }).promise();
        return Number(result && result.Attributes && result.Attributes.ApproximateNumberOfMessages);
    }
    async send(messages) {
        const failedMessages = [];
        const successfulMessages = [];
        const startIndex = 0;
        const messagesArr = !Array.isArray(messages) ? [messages] : messages;
        return this.sendBatch(failedMessages, successfulMessages, messagesArr, startIndex);
    }
    validate(options) {
        for (const option of requiredOptions) {
            if (!options[option]) {
                throw new Error(`Missing SQS producer option [${option}].`);
            }
        }
        if (options.batchSize > 10 || options.batchSize < 1) {
            throw new Error('SQS batchSize option must be between 1 and 10.');
        }
    }
    async sendBatch(failedMessages, successfulMessages, messages, startIndex) {
        const endIndex = startIndex + this.batchSize;
        const batch = messages.slice(startIndex, endIndex);
        const params = {
            QueueUrl: this.queueUrl,
            Entries: batch.map(types_1.toEntry)
        };
        const result = await this.sqs.sendMessageBatch(params).promise();
        const failedMessagesBatch = failedMessages.concat(result.Failed.map((entry) => entry.Id));
        const successfulMessagesBatch = successfulMessages.concat(result.Successful);
        if (endIndex < messages.length) {
            return this.sendBatch(failedMessagesBatch, successfulMessagesBatch, messages, endIndex);
        }
        if (failedMessagesBatch.length === 0) {
            return successfulMessagesBatch;
        }
        throw new Error(`Failed to send messages: ${failedMessagesBatch.join(', ')}`);
    }
}
exports.Producer = Producer;
Producer.create = (options) => {
    return new Producer(options);
};
